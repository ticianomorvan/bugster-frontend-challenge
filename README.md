# Bugster Front-End Challenge

Referencia: [Frontend Dev Challenge - Bugster](https://hazel-allium-573.notion.site/Frontend-Dev-Challenge-Bugster-2242abea27a8805b9fddd807f5796c17)

# Notas de desarrollo

En base a los requsitos esperados para este _challenge_, tomé ciertas decisiones que valen la aclaración:

1. No usé una librería de iconos convencional, como puede ser `lucide-react`, sino que descargué exactamente los mismos iconos que aparecen en el diseño en Figma, como `.svg` que usé como componentes de React. Esto no es recomendable para un proyecto real, puesto que perdemos gran capacidad de personalización o de plano es más complicado, ya que debemos editar los archivos de forma directa. Como la premisa del _challenge_ era el _pixel-perfect_ decidí usar esos mismos iconos; en otro caso, hubiese usado una librería.
2. Utilicé una función de utilidad `cn` en la mayoría de casos. Esta función se puede ver mucho en proyectos que usan `@shadcn/ui`, pero en este caso solo tomé esa parte para hacer más legibles los casos donde dos clases se superponen o debía agregar clases por más de una condición.
3. Utilicé la librería `typeit` para generar el efecto de la escritura en el botón "Add Property". Esto fue con fines de facilitar el desarrollo temprano y, sabiendo que es una librería con muchos años en mantenimiento, lograr un mejor resultado que no se preste a fallos fáciles de _edge cases_.
4. Todo el código importante está comentado en inglés. Desde hace años que escribo todo lo relacionado a código en inglés, no en particular porque sean proyectos donde trabajen personas angloparlantes, sino por comodidad y cercanía al mundo open-source. Lo dejo como aclaración para que no quede dudas de que son comentarios hechos por mí.
5. El _popover_ que se desplegaría cuando el usuario hace click en "Buy" o "Rent" es interactivo. Supuse que no se esperaba que lo haga estático, así que utilicé componentes _headless_ de Radix UI para construirlos. Ambos botones despliegan el mismo componente, ya que no hay más contexto acerca de si son o no diferentes.
6. La cuadrícula de imágenes de la derecha es **recursiva**. Propuse esta implementación porque noté un patrón interesante en como se incluían las imágenes: la primera casilla contenía las otras tres imágenes con la primera imagen del conjunto mayor como la última de este subconjunto. Entonces, en vez de simplemente crear una estructura estática, implementé recursividad de máximo dos niveles (principal y secundario), que genera consecuencias en los _delays_ de las animaciones y el estilo final de cada imagen. En un _hero_ real, quizá se podría implementar de forma directa.
7. Definí los colores por su nombre en el archivo de Figma, en vez de darles nombres significativos. Como no estamos planteando en este caso un _design system_ particular para un proyecto de múltiples páginas o sitios, creí más importante la correlación directa con los colores encontrables en el archivo de Figma. Así, podemos hacer la relación 1:1 con los colores del repositorio y los de la plataforma.
8. Actualización, decidí agregar una simple transición desde el perfil más pequeño de responsive design de Chrome (`325px`) hasta el tamaño del diseño original, tomando ciertas libertades. 
9. Finalmente, un agradecimiento a Bugster por la oportunidad de realizar este ejercicio :)